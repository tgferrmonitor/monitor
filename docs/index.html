<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <title>Relat√≥rios Roblox</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="./styles.css" />
  </head>
  <body>
    <div class="site-font">
      <div class="container">
        <div class="header">
          <h1>üìä Relat√≥rios de Jogadores Roblox</h1>
          <div class="muted">Visual moderno</div>
        </div>

        <div class="controls">
          <label>Data: <input type="date" id="date" /></label>
          <label
            >Jogador:
            <select id="playerFilter">
              <option value="">(todos)</option>
            </select></label
          >
          <label
            >Ordenar por:
            <select id="sortBy">
              <option value="presence">Presen√ßa</option>
              <option value="hours">Horas</option>
            </select></label
          >
          <label
            >Ordem:
            <select id="sortDir">
              <option value="desc">Desc</option>
              <option value="asc">Asc</option>
            </select></label
          >
          <div class="flex">
            <button class="btn" onclick="loadReport()">Carregar</button>
            <button class="btn secondary" onclick="setTodayInputs()">
              Hoje
            </button>
            <button class="btn secondary" onclick="exportCSV()">
              Export CSV
            </button>
            <button class="btn secondary" onclick="printReport()">
              Imprimir
            </button>
          </div>
        </div>

        <div id="reportArea" class="card"></div>
      </div>
    </div>

    <script>
      let BUCKET_URL = 'https://bucket-tgferr-monitor.br-se1.magaluobjects.com';
      // Opcional: URL para consultar a data do servidor (ex: http://host:3001/server-date)
      // Pode ser definida em docs/config.json como SERVER_DATE_URL para ambientes distribu√≠dos.
      let SERVER_DATE_URL = null;

      // Tenta carregar docs/config.json para sobrepor BUCKET_URL em desenvolvimento
      let playersMap = new Map();

      function convertToDDMMYY(isoDate) {
        const [year, month, day] = isoDate.split('-');
        const yy = year.slice(-2); // Pegar √∫ltimos 2 d√≠gitos do ano
        return `${day}${month}${yy}`;
      }

      // Parse ISO 'YYYY-MM-DD' into local Date (avoid UTC shift)
      function parseISOToLocalDate(iso) {
        const [y, m, d] = iso.split('-').map((s) => parseInt(s, 10));
        return new Date(y, m - 1, d);
      }

      async function loadConfig() {
        // Apenas carregar config.json em desenvolvimento (localhost / 127.0.0.1 / file:)
        try {
          const host =
            (typeof location !== 'undefined' && location.hostname) || '';
          const proto =
            (typeof location !== 'undefined' && location.protocol) || '';
          if (
            host !== 'localhost' &&
            host !== '127.0.0.1' &&
            proto !== 'file:'
          ) {
            // em produ√ß√£o (GitHub Pages) n√£o carregamos o config local
            return;
          }

          const res = await fetch('./config.json');
          if (!res.ok) return;
          const cfg = await res.json();
          if (cfg.BUCKET_URL) {
            BUCKET_URL = cfg.BUCKET_URL;
            console.log('Config carregada (dev):', BUCKET_URL);
          }
          if (cfg.SERVER_DATE_URL) {
            SERVER_DATE_URL = cfg.SERVER_DATE_URL.replace(/\/+$/, '');
            console.log('SERVER_DATE_URL (dev):', SERVER_DATE_URL);
          }
        } catch (e) {
          // silencioso - manter fallback embutido
        }
      }

      // Tenta carregar players.json local para mapear IDs -> nomes
      async function loadPlayers() {
        try {
          const res = await fetch('./players.json');
          if (!res.ok) return;
          const list = await res.json();
          for (const p of list) playersMap.set(String(p.id), p);
          console.log('Players carregados localmente', playersMap.size);
          // preencher select de filtro
          const sel = document.getElementById('playerFilter');
          for (const p of list) {
            const opt = document.createElement('option');
            opt.value = String(p.id);
            opt.textContent = p.name;
            sel.appendChild(opt);
          }
        } catch (e) {
          // silencioso
        }
      }

      // Busca dados do arquivo di√°rio (formato DDMMYY.json)
      async function fetchDailyData(isoDate) {
        const filename = convertToDDMMYY(isoDate);
        const base = BUCKET_URL;
        const url = `${base}/${filename}.json`;

        try {
          console.log(`Carregando dados di√°rios: ${url}`);
          const res = await fetch(url);
          if (res.ok) {
            const data = await res.json();
            if (Array.isArray(data)) {
              console.log(`‚úÖ Dados encontrados: ${data.length} entradas`);
              return data;
            }
          } else {
            console.log(`Arquivo n√£o encontrado (${res.status}): ${url}`);
          }
        } catch (e) {
          console.log(`Erro ao carregar ${url}:`, e.message);
        }
        return [];
      }

      // Calcula estat√≠sticas por player baseado nos timestamps das entradas
      function calculatePlayerStats(dailyData) {
        const stats = {};
        // Converter timestamps para ms num√©ricos uma vez
        dailyData.forEach((entry) => {
          entry._ts = Date.parse(entry.timestamp);
        });
        // Agrupar entradas por player
        const entriesByPlayer = {};
        for (const entry of dailyData) {
          const player = entry.player;
          if (!entriesByPlayer[player]) entriesByPlayer[player] = [];
          entriesByPlayer[player].push(entry);
        }
        // Processar cada player separadamente
        for (const player in entriesByPlayer) {
          const entries = entriesByPlayer[player];
          // Ordenar por timestamp ascendente usando _ts
          entries.sort((a, b) => a._ts - b._ts);
          // Inicializar stats para o player
          stats[player] = {
            totalMinutes: 0,
            statusCount: {},
            minutesByStatus: {},
            gameCount: {},
            lastStatus: null,
            lastGame: null,
            lastTimestamp: null,
          };
          let prevEntry = null;
          for (const entry of entries) {
            if (prevEntry) {
              // calcular diferen√ßa real entre timestamps usando _ts
              const diffMs = entry._ts - prevEntry._ts;
              // s√≥ acumular se diffMs for n√∫mero v√°lido
              if (Number.isFinite(diffMs) && diffMs > 0) {
                const diffMin = diffMs / 1000 / 60;
                stats[player].totalMinutes += diffMin;
                // Acumular minutos por status anterior
                const prevStatus = prevEntry.status || 'Desconhecido';
                stats[player].minutesByStatus[prevStatus] =
                  (stats[player].minutesByStatus[prevStatus] || 0) + diffMin;
                stats[player].statusCount[prevStatus] =
                  (stats[player].statusCount[prevStatus] || 0) + 1;
                // Contar jogos anteriores
                const prevGame = prevEntry.jogo || 'N/A';
                stats[player].gameCount[prevGame] =
                  (stats[player].gameCount[prevGame] || 0) + 1;
              }
            }
            // Atualizar √∫ltimo status/jogo
            if (
              !stats[player].lastTimestamp ||
              entry.timestamp > stats[player].lastTimestamp
            ) {
              stats[player].lastStatus = entry.status || 'Desconhecido';
              stats[player].lastGame = entry.jogo || 'N/A';
              stats[player].lastTimestamp = entry.timestamp;
            }
            prevEntry = entry;
          }
        }
        return stats;
      }

      // Carrega relat√≥rio para um dia (exibe presen√ßas do primeiro dia) e agrega horas no intervalo
      async function loadReport() {
        const dateIso = document.getElementById('date').value;
        if (!dateIso) return alert('Escolha uma data!');

        // filtro por jogador (opcional)
        const playerFilter = document.getElementById('playerFilter').value;

        try {
          // Buscar dados di√°rios no novo formato
          const dailyData = await fetchDailyData(dateIso);
          if (dailyData.length === 0) {
            throw new Error('Nenhum dado encontrado para esta data');
          }

          // Calcular estat√≠sticas por player
          const playerStats = calculatePlayerStats(dailyData);

          // Aplicar filtro por jogador (se houver)
          let filteredData = dailyData;
          if (playerFilter) {
            filteredData = dailyData.filter(
              (entry) =>
                entry.player.includes(playerFilter) ||
                entry.player === `Player ${playerFilter}`
            );
          }

          renderReport(filteredData, playerStats);
        } catch (e) {
          alert('Erro: ' + e.message);
        }
      }

      // Carrega config e players ao iniciar (n√£o bloqueante)
      loadConfig();
      loadPlayers();

      let chartInstance = null;

      function renderReport(dailyData, playerStats) {
        const div = document.getElementById('reportArea');
        div.innerHTML = '';

        if (!Array.isArray(dailyData) || dailyData.length === 0) {
          div.innerHTML = '<p>Nenhum dado dispon√≠vel para esta data.</p>';
          return;
        }

        // Remover gr√°fico
        // Construir tabela de hist√≥rico de entradas
        const sortedData = dailyData
          .slice()
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        let historyHtml =
          '<h3>Hist√≥rico de Presen√ßa</h3>' +
          '<div class="table-wrap"><table>' +
          '<thead><tr><th>Hor√°rio</th><th>Player</th><th>Status</th><th>Jogo</th></tr></thead><tbody>';
        for (const entry of sortedData) {
          const time = new Date(entry.timestamp).toLocaleTimeString();
          const pid = entry.player;
          const m = /^Player (\d+)$/.exec(pid);
          const name =
            m && playersMap.get(m[1])
              ? playersMap.get(m[1]).displayName || playersMap.get(m[1]).name
              : pid;
          historyHtml += `<tr><td>${time}</td><td>${name}</td><td>${entry.status}</td><td>${entry.jogo}</td></tr>`;
        }
        historyHtml += '</tbody></table></div>';
        // Div ser√° preenchida com as se√ß√µes abaixo

        // Construir tabela de status atual (√∫ltimo status de cada player)
        let currentHtml =
          '<h3>Status Atual dos Players</h3>' +
          '<div class="table-wrap"><table>' +
          '<thead><tr><th>Player</th><th>Status</th><th>Jogo</th><th>Hor√°rio</th></tr></thead><tbody>';
        for (const [playerKey, stats] of Object.entries(playerStats)) {
          const m = /^Player (\d+)$/.exec(playerKey);
          const name =
            m && playersMap.get(m[1])
              ? playersMap.get(m[1]).displayName || playersMap.get(m[1]).name
              : playerKey;
          const ts = new Date(stats.lastTimestamp).toLocaleTimeString();
          currentHtml += `<tr><td>${name}</td><td>${stats.lastStatus}</td><td>${stats.lastGame}</td><td>${ts}</td></tr>`;
        }
        currentHtml += '</tbody></table></div>';
        // Exibir status atual primeiro
        div.innerHTML = currentHtml;
        // Exibir hist√≥rico em accordion abaixo
        const historySection =
          '<details class="card" style="margin-top:16px">' +
          '<summary style="cursor:pointer;font-weight:600;">Hist√≥rico de Presen√ßa</summary>' +
          historyHtml +
          '</details>';
        div.innerHTML += historySection;
      }

      // Ao carregar a p√°gina, preencher as datas (hoje) e players
      function setTodayInputs() {
        // Usa a data local do cliente; o frontend aplicar√° fallback caso o
        // backend esteja gravando com outro timezone (SERVER_DATE_URL pode ajudar).
        const now = new Date();

        const pad = (n) => n.toString().padStart(2, '0');
        const iso = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(
          now.getDate()
        )}`;
        document.getElementById('date').value = iso;
        // carregar imediatamente para conveni√™ncia
        try {
          loadReport();
        } catch (e) {
          /* ignore */
        }
      }

      // Export CSV da tabela atual
      function exportCSV() {
        const table = document.querySelector('#reportArea table');
        if (!table) return alert('Nada para exportar');
        const rows = [];
        for (const tr of table.querySelectorAll('tr')) {
          const cols = Array.from(tr.querySelectorAll('th,td')).map((n) =>
            n.textContent.trim()
          );
          rows.push(cols.join(','));
        }
        const csv = rows.join('\n');
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `report-${
          document.getElementById('date').value || 'report'
        }.csv`;
        a.click();
        URL.revokeObjectURL(url);
      }

      function printReport() {
        window.print();
      }

      // inicializar
      setTodayInputs();
      loadPlayers();
    </script>
  </body>
</html>
